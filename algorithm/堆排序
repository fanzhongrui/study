二叉堆的定义
二叉堆是完全二叉树或者是近似完全二叉树。
二叉堆满足两个特性：
  1.父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。
  2.每个节点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）
  
  当父节点的键值总是大于或等于任何一个子节点的键值时为最大堆。
  当父节点的键值总是小于或等于任何一个子节点的键值时为最小堆。
  
  由于其他几种堆（二项式堆，斐波那契堆等）用的较少，一般将二叉堆就简称为堆
  
堆的存储
  一般都用数组表示堆，i节点的父节点下标为（i－1）／2。
  它的左右子节点下标分别为2*i＋1和2*i＋2.
  
堆的操作——插入删除
  堆的插入
      每次插入都是将数据放在数组最后。可以发现这个新数据的父节点到根节点必然为一个有序的数列。
      现在的任务是将这个新数据插入到这个有序数据中————类似于直接插入排序中将一个数据并入到有序区间中。
      插入一个新数据时堆的调整代码：
      //新加入i节点，其父节点为（i－1）／2
      void　MinHeapFixup(int a[], int i){
          int j, tmp;
          tmp = a[i];
          j = (i-1)/2;  //父节点
          while(j >= 0 && i != 0){
              if(a[j] <= tmp)break;
              a[i] = a[j];    //把较大的子节点往下移动，替换它的子节点
              i = j;
              j = (i-1)/2;
          }
          a[i] = tmp;
      }
        更简短的表达为：
        void MinHeapFixup(int a[], int i){
            for(int j=(i-1)/2; (j>=0 && i!=0)&& a[i]>a[j]; i=j,j=(i-1)/2)
              Swap(a[i], a[j]);
        }
        插入时：
        //在最小堆中加入新的数据nNum
        void MinHeapAddNumber(int a[], int n, int nNum){
            a[n] = nNum;
            MinHeapFixup(a, n);
        }
  堆的删除 
    按定义，堆中每次都只能删除第0个数据。为了便于重建堆，
    实际的操作是将最后一个数据的值赋给根节点，然后再从根节点开始进行一次从上向下的调整。
    调整时先在左右儿子节点中找最小的，如果父节点比这个最小的子节点还小就说明不需要调整了，反之将父节点和它交换后再考虑后面的节点。
    相当于从根节点将一个数据“下沉”的过程。
    下面给出代码：
    //从i节点开始调整，n为节点总数 从0开始计算 i节点的子节点为2*i＋1，2*i+2
    void minHeapFixdown(int a[], int i, int n){
        int j, tmp;
        tmp = a[i];
        j = 2*i+1;
        while(j < n){
          if(j+1 < n && a[j+1] < a[j])    //在左右孩子中找最小的
              j++;
          if(a[j] >= temp)break;
          a[i] = a[j];      //把较小的子节点往上移动，替换它的父节点
          i = j;
          j = 2*i+1;
      }
      a[i] = tmp;
  }
  //在最小堆中删除数
  void MinHeapDeleteNumber(int a[], int n){
      Swap(a[0],a[n-1]);
      MinHeapFixdown(a, 0, n-1);
  }

堆化数组
  考虑如何对一个数组进行堆化操作。
  不必一个一个数加入堆中，从第一个非叶节点开始，依次对所有非叶节点向下调整。
  //建立最小堆
  void MakeMinHeap(int a[], int n){
      for(int i=n/2-1; i>0; i--)
          MinHeapFixdown(a, i, n);
  }
  
  堆排序
  首先可以看到堆建好之后堆中第0个数据是堆中最小的数据。取出这个数据再执行下堆的删除操作。
  这样堆中第0个数据又是堆中最小的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。
  由于堆也是用数组模拟的，故堆化数组后，第一次将A［0］与A［n－1］交换，再对A［0.。。n－2］重新恢复堆。
  第二次将A［0］与A［n－2］交换，再对A［0.。。n－3］重新恢复堆，重复这样的操作直到A［0］与A［1］交换。
  由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组是降序排列。
  类似于直接选择排序。
  
  使用最小堆排序后是递减数组，要得到递增数组，可以使用最大堆。
  由于每次重新恢复堆的时间复杂度为O（logN），共N－1次重新恢复堆操作，再加上前面建堆时N／2次向下调整，每次调整时间复杂度也为O（logN）。
  两次操作时间相加还是O（N＊logN）。
  故堆排序的时间复杂度为O（N＊logN）。
      
      
      
      
      
