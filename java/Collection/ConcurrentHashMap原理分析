两个线程需要同时访问一个中间临界区（Queue），比如常会用缓存作为外部文件的副本（HashMap）。
三种并发集合类型有concurrent，copyonright，queue。
本文介绍ConcurrentHashMap。

通过分析Hashtable知道，synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，
ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。
它使用了多个锁来控制对hash表的不同部分进行的修改。
ConcurrentHashMap内部使用段（Segment）来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。
只要多个修改操作发生在不同的段上，它们就可以并发进行。
有些方法需要跨段，比如size（）和containsValue（），它们可能需要锁定整个表而不仅仅是某个段，
  这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。
这里“按顺序”很重要，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，
  但是，仅仅是将数组声明为final的并不保证数组成员也是final的，需要实现上的保证。
由于获得锁的顺序是固定的，这可以确保不会出现死锁。

一、结构解析
  ConcurrentHashMap和Hashtable主要区别是围绕着锁的粒度以及如何锁。
  ConcurrentHashMap可以简单理解为把一个大的Hashtable分解成多个，形成了锁分离。
  而Hashtable的实现方式是——锁整个hash表
  
二、应用场景
  当有一个大数组时需要在多个线程共享时就可以考虑是否把它给分成多个节点了，避免大锁。
  并可以考虑通过hash算法进行一些模块定位。
  
  其实不止用于线程，当设计数据表的事务时（事务某种意义上也是同步机制的体现），可以把一个表看成一个需要同步的数组，
    如果操作的表数据太多时就可以考虑事务分离了（这也是为什么要避免大表的出现），比如把数据进行字段拆分，水平分表等
    
三、源码解读
  ConcurrentHashMap中主要实体类有三个：ConcurrentHashMap（整个Hash表），Segment（桶），HashEntry（节点）
      final Segment<K, V>[] segments;  //the segments, each of which is a specialized hash table
  
  不变（Immutable）和易变（Volatile）
  ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，
  如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。
  ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。
  HashEntry代表每个hash链中的一个节点，其结构如下：
      static final class HashEntry<K,V>{
          final K key;
          final int hash;
          volatile V value;
          final HashEntry<K,V> next;
      }
  可以看到除了value不是final的，其它值都是final的，这意味着不能从hash链的中间或尾部添加或删除节点，因为这需要修改next引用值，
    所有节点的修改只能从头部开始。
  对于put操作，可以一律添加到Hash链的头部。但是对于remove操作，可能需要从中间删除一个节点，
      这就需要将要删除节点的前面所有节点整个复制一遍，最后一个节点指向要删除节点的下一个节点。
  为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁。
  
其它
    为了加快定位段以及段中hash槽的速度，每个段hash槽的个数都是2^n,这使得通过位运算就可以定位段和段中hash槽的位置。
