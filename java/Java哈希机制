通过分析HashMap和HashSet源码分析其Hash存储机制

  对于HashSet而言，系统采用hash算法决定集合元素的存储位置，这样可以保证能快速存、取集合元素；
  对于HashMap而言，系统key-value当成一个整体进行处理，系统总是根据Hash算法来计算key-value的存储位置，这样可以保证能快速存、取Map的key-value对。
  虽然集合号称存储的是Java对象，但实际上并不会真正将Java对象放入Set集合中，只是在Set集合中保留这些对象的引用。
  即，Java集合实际上是多个引用变量所组成的集合，这些引用变量指向实际的Java对象。
  
HashMap的存储实现
      HashMap<String , Double> map = new HashMap<String , Double>(); 
      map.put("语文" , 80.0); 
      map.put("数学" , 89.0); 
      map.put("英语" , 78.2);
    HashMap采用一种所谓的“Hash算法”来决定每个元素的存储位置。
    当程序执行map.put(“语文”，80.0)；时，系统将调用“语文”的hashCode()方法得到其hashCode值————每个Java对象都有hashCode（）方法，都可以通过该方法获得它的hashCode值。
    得到这个对象的hashCode值之后，系统会根据该HashCode值来决定该元素的存储位置。
      public V put(K key, V value) 
       { 
      	 // 如果 key 为 null，调用 putForNullKey 方法进行处理
      	 if (key == null) 
      		 return putForNullKey(value); 
      	 // 根据 key 的 keyCode 计算 Hash 值
      	 int hash = hash(key.hashCode()); 
      	 // 搜索指定 hash 值在对应 table 中的索引
       <strong> int i = indexFor(hash, table.length);</strong>
      	 // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素
      	 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) 
      	 { 
      		 Object k; 
      		 // 找到指定 key 与需要放入的 key 相等（hash 值相同
      		 // 通过 equals 比较放回 true）
      		 if (e.hash == hash &amp;&amp; ((k = e.key) == key 
      			 || key.equals(k))) 
      		 { 
      			 V oldValue = e.value; 
      			 e.value = value; 
      			 e.recordAccess(this); 
      			 return oldValue; 
      		 } 
      	 } 
      	 // 如果 i 索引处的 Entry 为 null，表明此处还没有 Entry 
      	 modCount++; 
      	 // 将 key、value 添加到 i 索引处
      	 addEntry(hash, key, value, i); 
      	 return null; 
       }
       上面程序中用到了Map.Entry，每个Map.Entry其实就是一个key-value对。
       从上面程序中可以看出：当系统决定存储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。
       这也说明：Map集合中的value完全是key的附属，当系统决定了key的存储位置之后，value随之保存在那里即可。
       
       上面方法提供了一个hashCode()返回值来计算Hash码的方法：hash()，这个方法是一个纯粹的数学计算，其方法如下：
        static int hash(int h) 
          { 
              h ^= (h >>> 20) ^ (h >>> 12); 
              return h ^ (h >>> 7) ^ (h >>> 4); 
          }
      对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用hash(int  h)方法所计算得到的hash码值总是相同的。
      接下来程序会调用indexFor(int h, int length)方法来计算该对象应该保存在table数组的哪个索引处。
        static int indexFor(int h, int length) 
          { 
              return h & (length-1); 
          }
      这个方法总是通过h & (table.length-1)来得到该对象的保存位置
      而HashMap底层数组的长度总是2的n次方。
      当length总是2的倍数时，h & (length - 1)将是一个非常巧妙的设计：
          假设h=5, length = 16,那么h & (length-1)将得到5；
          h=6，length=16，那么h&(length-1)将得到6。。。。。h=15,length=16,那么h&(length-1)将得到15；
          但是当h=16,length=16时，那么h&(length-1)将得到0；
          当h=17,length=16,那么h&length-1将得到1
          这样保证计算得到的索引值总是位于table数组的索引之内。
          
      当程序试图将一个key-value对放入HashMap中时，程序首先根据该key的hashCode()返回值决定该Entry的存储位置：
          如果两个Entry的key的hashCode()
