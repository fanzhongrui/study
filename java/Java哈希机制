通过分析HashMap和HashSet源码分析其Hash存储机制

  对于HashSet而言，系统采用hash算法决定集合元素的存储位置，这样可以保证能快速存、取集合元素；
  对于HashMap而言，系统key-value当成一个整体进行处理，系统总是根据Hash算法来计算key-value的存储位置，这样可以保证能快速存、取Map的key-value对。
  虽然集合号称存储的是Java对象，但实际上并不会真正将Java对象放入Set集合中，只是在Set集合中保留这些对象的引用。
  即，Java集合实际上是多个引用变量所组成的集合，这些引用变量指向实际的Java对象。
  
HashMap的存储实现
      HashMap<String , Double> map = new HashMap<String , Double>(); 
      map.put("语文" , 80.0); 
      map.put("数学" , 89.0); 
      map.put("英语" , 78.2);
    HashMap采用一种所谓的“Hash算法”来决定每个元素的存储位置。
    当程序执行map.put(“语文”，80.0)；时，系统将调用“语文”的hashCode()方法得到其hashCode值————每个Java对象都有hashCode（）方法，都可以通过该方法获得它的hashCode值。
    得到这个对象的hashCode值之后，系统会根据该HashCode值来决定该元素的存储位置。
      public V put(K key, V value) 
       { 
      	 // 如果 key 为 null，调用 putForNullKey 方法进行处理
      	 if (key == null) 
      		 return putForNullKey(value); 
      	 // 根据 key 的 keyCode 计算 Hash 值
      	 int hash = hash(key.hashCode()); 
      	 // 搜索指定 hash 值在对应 table 中的索引
       <strong> int i = indexFor(hash, table.length);</strong>
      	 // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素
      	 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) 
      	 { 
      		 Object k; 
      		 // 找到指定 key 与需要放入的 key 相等（hash 值相同
      		 // 通过 equals 比较放回 true）
      		 if (e.hash == hash &amp;&amp; ((k = e.key) == key 
      			 || key.equals(k))) 
      		 { 
      			 V oldValue = e.value; 
      			 e.value = value; 
      			 e.recordAccess(this); 
      			 return oldValue; 
      		 } 
      	 } 
      	 // 如果 i 索引处的 Entry 为 null，表明此处还没有 Entry 
      	 modCount++; 
      	 // 将 key、value 添加到 i 索引处
      	 addEntry(hash, key, value, i); 
      	 return null; 
       }
       上面程序中用到了Map.Entry，每个Map.Entry其实就是一个key-value对。
       从上面程序中可以看出：当系统决定存储HashMap中的key-value对时，完全没有考虑Entry中的value，仅仅只是根据key来计算并决定每个Entry的存储位置。
       这也说明：Map集合中的value完全是key的附属，当系统决定了key的存储位置之后，value随之保存在那里即可。
       
       上面方法提供了一个hashCode()返回值来计算Hash码的方法：hash()，这个方法是一个纯粹的数学计算，其方法如下：
        static int hash(int h) 
          { 
              h ^= (h >>> 20) ^ (h >>> 12); 
              return h ^ (h >>> 7) ^ (h >>> 4); 
          }
      对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用hash(int  h)方法所计算得到的hash码值总是相同的。
      接下来程序会调用indexFor(int h, int length)方法来计算该对象应该保存在table数组的哪个索引处。
        static int indexFor(int h, int length) 
          { 
              return h & (length-1); 
          }
      这个方法总是通过h & (table.length-1)来得到该对象的保存位置
      而HashMap底层数组的长度总是2的n次方。
      当length总是2的倍数时，h & (length - 1)将是一个非常巧妙的设计：
          假设h=5, length = 16,那么h & (length-1)将得到5；
          h=6，length=16，那么h&(length-1)将得到6。。。。。h=15,length=16,那么h&(length-1)将得到15；
          但是当h=16,length=16时，那么h&(length-1)将得到0；
          当h=17,length=16,那么h&length-1将得到1
          这样保证计算得到的索引值总是位于table数组的索引之内。
          
      当程序试图将一个key-value对放入HashMap中时，程序首先根据该key的hashCode()返回值决定该Entry的存储位置：
          如果两个Entry的key的hashCode()返回值相同，那么它们的存储位置相同。
      如果这两个Entry的key通过equals比较返回true，新添加Entry的value将覆盖集合中原有Entry的value，但key不会覆盖。
      如果这两个Entry的key通过equals比较返回false，新添加的Entry将与集合中原有Entry形成Entry链，而且新添加的Entry位于Entry链的头部。
      当向HashMap中添加key-value对，由其key的hashCode()返回值决定该key-value对（就是Entry对象）的存储位置。
      当两个Entry对象的key的hashCode()返回值相同时，将由key通过equals()比较值决定是采用覆盖行为（返回true），还是产生Entry链（返回false）。
      上面程序中还调用了addEntry(hash, key, value, i);代码，其中addEntry是HashMap提供的一个包访问权限的方法，该方法仅用于添加一个key-value对。
          void addEntry(int hash, K key, V value, int bucketIndex) 
              { 
                  // 获取指定 bucketIndex 索引处的 Entry 
                  Entry<K,V> e = table[bucketIndex]; 	 // ①
                  // 将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry 
                  table[bucketIndex] = new Entry<K,V>(hash, key, value, e); 
                  // 如果 Map 中的 key-value 对的数量超过了极限
                  if (size++ >= threshold) 
                      // 把 table 对象的长度扩充到 2 倍。
                      resize(2 * table.length); 	 // ②
              }
        上面方法的代码中包含了一个非常优雅的设计：系统总是将新添加的Entry对象放入table数组的bucketIndex索引处————
            如果bucketIndex索引处已经有了一个Entry对象，那新添加的Entry对象指向原有的Entry对象（产生一个Entry链），
            如果bucketIndex索引处没有Entry对象，即e变量是null，也就是新放入的Entry对象指向null，也就是没有产生Entry链。
            
Hash算法的性能选项
    由以上代码可以看出，在同一个bucket存储Entry链的情况下，新放入的Entry总是位于bucket中，而最早放入该bucket中的Entry则位于这个Entry链的最末端。
    
    上面程序中还有这样两个变量：
        size:该变量保存了该HashMap中所包含的key-value对的数量。
        threshold：该变量包含了HashMap能容纳的key-value对的极限，它的值等于HashMap的容量乘以负载因子（load factor）。
        
    当Size++ >= threshold时，HashMap会自动调用resize方法扩充HashMap的容量。每扩充一次，HashMap的容量就增大一倍。
    
    使用的table数组其实就是一个普通数组，每个数组都有一个固定的长度，这个数组的长度就是HashMap的容量。
    HashMap包含如下几个构造器：
        HashMap():构建一个初始容量为16，负载因子为0.75的hashMap
        HashMap（int initialCapacity）：构建一个初始容量为initialCapacity，负载因子为0.75的HashMap
        HashMap（int initialCapacity, float loadFactor）：以指定初始容量、指定的负载因子创建一个HashMap。
    
    当创建一个HashMap时，系统会自动创建一个table数组来保存HashMap中的Entry，下面是HashMap中一个构造器的代码：
        // 以指定初始化容量、负载因子创建 HashMap 
         public HashMap(int initialCapacity, float loadFactor) 
         { 
        	 // 初始容量不能为负数
        	 if (initialCapacity < 0) 
        		 throw new IllegalArgumentException( 
        		"Illegal initial capacity: " + 
        			 initialCapacity); 
        	 // 如果初始容量大于最大容量，让出示容量
        	 if (initialCapacity > MAXIMUM_CAPACITY) 
        		 initialCapacity = MAXIMUM_CAPACITY; 
        	 // 负载因子必须大于 0 的数值
        	 if (loadFactor <= 0 || Float.isNaN(loadFactor)) 
        		 throw new IllegalArgumentException( 
        		 loadFactor); 
        	 // 计算出大于 initialCapacity 的最小的 2 的 n 次方值。
        	 int capacity = 1; 
        	 while (capacity < initialCapacity) 
        		 capacity <<= 1; 
        	 this.loadFactor = loadFactor; 
        	 // 设置容量极限等于容量 * 负载因子
        	 threshold = (int)(capacity * loadFactor); 
        	 // 初始化 table 数组
        	 table = new Entry[capacity]; 			 // ①
        	 init(); 
         }
        
        上面代码中包含了一个简洁的代码实现：找出大于initialCapacity的，最小的2的n次方值，并将其作为HashMap的实际容量（由capacity变量保存）。
         table的实质就是一个数组，一个长度为capacity的数组。
          对于HashMap及其子类而言，它们采用Hash算法来决定集合中元素的存储位置。
          当系统开始初始化HashMap时，系统会创建一个长度为capacity的Entry数组，这个数组里可以存储元素的位置被称为“桶（bucket）”，每个bucket都有其指定索引，系统可以根据其索引快速访问该bucket里存储的元素。
          
          无论何时，HashMap的每个“桶”只存储一个元素（即一个Entry），由于Entry对象可以包含一个引用变量（就是Entry构造器的最后一个参数）用于指向下一个Entry，
              因此可能出现的情况是：HashMap的bucket中只有一个Entry，但这个Entry指向另一个Entry————这就形成了一个Entry链。
              
  HashMap的读取实现
        当HashMap的每个bucket里存储的Entry只是单个Entry————也就是没有通过指针产生Entry链时，
        
        
        
        
        
        
        
      
