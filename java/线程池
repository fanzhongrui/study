线程池
作用：
  线程池的作用就是限制系统中执行线程的数量。
  根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；
  少了浪费系统资源，多了造成系统拥挤效率不高。
  用线程池控制线程数量，其他线程排队等候。一个任务执行完毕，再从队列中取最前面的任务开始执行。
  若队列中没有等待进程，线程池的这一资源处于等待。
  当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。
  
为什么要用线程池：
  1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
  2.可以根据系统的承受能力，调整线程池中工作线程的数目，防止因为消耗过多的内存，而把服务器累趴（每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机）。
  
java里线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。
真正的线程池接口是ExecutorService。

比较重要的几个类：
  ExecutorService：真正的线程池接口。
  ScheduledExecutorService:和Timer／TimerTask类似，解决那些需要重复执行的任务
  ThreadPoolExecutor:ExecutorService的默认实现
  ScheduledThreadPoolExecutor:继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。
  
线程池配置比较复杂，很有可能配置的线程池不是较优的，因此在Executors类里提供了一些静态工厂，生成一些常用的线程池。
1.newSingleThreadExecutor
  创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。
  如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。
  此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
2.newFixedThreadPool
  创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
  线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
3.newCachedThreadPool
  创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，就会回收部分空闲（60秒不执行任务）的线程，
  当任务数增加时，此线程池又可以添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者JVM）能够创建的最大线程数。
4.newScheduledThreadPool
  创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。
  
public class MyThread extends Thread{
  @Override
  public void run(){
    System.out.println(Thread.currentThread().getName()+"正在执行。。");
  }
}
public class TestSingleThreadExecutor｛
  public static void main(String[] arags){
    //创建一个可重用固定线程数的线程池
    ExecutorService pool = Executors.newSingleThreadExecutor();
    //ExecutorService pool = Executors.newCachedThreadPool();
    Thread t1 = new MyThread();
    Thread t2 = new MyThread();
    Thread t3 = new MyThread();
    Thread t4 = new MyThread();
    Thread t5 = new MyThread();
    //将线程放入池中进行执行
    pool.execute(t1);
    pool.execute(t2);
    pool.execute(t3);
    pool.execute(t4);
    pool.execute(t5);
    //关闭线程池
    pool.shutdown();
  }
}

newScheduledThreadPool  
public class TestScheduledThreadPoolExecutor｛
  public static void main(String[] args){
    ScheduledThreadPoolExecutor exec = new ScheduledThreadPoolExecutor(1);
    exec.scheduleAtFixRate(new Runnable(){//每隔一段时间就触发异常
        @Override
        public void run(){
          System.out.println("===============");
        }
    }, 1000, 5000, TimeUnit.MILLISECONDS);
    exec.scheduleAtFixedRate(new Runnable(){
        @Override
        public void run(){
            System.out.println(System.nanoTime());
        }
    }, 1000, 2000, TimeUnit.MILLISECONDS);
  }
}

ThreadPoolExecutor详解
ThreadPoolExecutor的完整构造方法的签名是：ThreadPoolExecutor（int corePoolSize，
int maximumPoolSize, long keepAliveTime, TimeUnit unit, 
BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, 
RejectedExecutionHandler handler）.
corePoolSize---池中所保存的线程数，包括空闲线程。
maximumPoolSize---池中允许的最大线程数。
keepAliveTime---当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。
unit---keepAliveTime参数的时间单位。
workQueue---执行前用于保持任务的队列。此队列仅保持由execute方法提交的Runnable任务。
threadFactory---执行程序创建新线程时使用的工厂。
handler---由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序

ThreadPoolExecutor是Executors类的底层实现。
  
JDK文档：“强烈建议程序员使用较为方便的Executors工厂方法Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）、
Executors.newFixedThreadPool(int)（固定大小线程池）Executors.newSingleThreadExecutor()（单个后台线程），它们均为大多数使用场景预定义了设置。”

  
  
  
  
  
  
  
  
  
  
