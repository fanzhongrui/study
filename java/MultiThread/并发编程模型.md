>并发系统可以采用多种并发编程模型来实现。并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。
不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。 

###**并发模型与分布式系统**
并发模型类似于分布式系统中使用的很多体系结构。在并发系统中线程之间可以相互通信。在分布式系统中进程之间也可以相互通信（进程有可能在不同的机器中）。
进程和线程之间具有很多相似性。所以很多并发模型通常类似于各种分布式系统架构。  
分布式系统在处理网络失效、远程主机或进程宕掉等方面也面临着额外的挑战。但运行在巨型服务器上的并发系统也肯能遇到类似的问题，
比如一块CPU失效、一块网卡失效或一个磁盘损坏等情况。  
由于并发模型类似于分布式系统架构，因此它们通常可以互相借鉴思想。例如，为线程分配作业的模型一般与分布式系统的负载均衡系统比较相似。
同样，它们在日志记录、失效转移、幂等性等错误处理技术上也具有相似性。
>幂等性，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。 

##**一、并行工作者**
第一种并发模型是并行工作者模型。传入的作业会被分配到不同的工作者上。  

![并行工作者](concurrency-models-1.png) 

在并行工作者模型中，委派者（Delegator）将传入的作业分配给不同的工作者。每个工作者完成整个任务。
工作者们并行运作在不同的线程上，甚至可能在不同的CPU上。  

在Java应用系统中，并行工作者模型是最常见的并发模型。`java.util.concurrent`包中的许多并发实用工具都是设计用于这个模型的。
Java企业级（J2EE）应用服务器的设计中也有这个模型。  

###**并行工作者模型的优点**
并行工作者模式的优点是，很容易理解。只需要添加更多的工作者来提高系统的并行度。  
例如，做一个网络爬虫，可以试试使用不同数量的工作者抓取到一定数量的页面，然后看看多少数量的工作者消耗的时间最短（即性能最高）。
由于网络爬虫是一个IO密集型工作，最终结果很有可能是电脑中的每个CPU或核心分配了几个线程。每个CPU若只分配一个线程可能有点少，因为在等待数据下载的过程中CPU将会空闲大量时间。
###**并行工作者模型的缺点**
####**共享状态可能会很复杂**
共享的工作者经常需要访问一些共享数据，无论是内存中的或者共享的数据库中的。如下图：  
![并发编程模型](concurrency-models-2.png)  

有些共享状态是在像作业队列这样的通信机制下。但也有一些
