Java锁机制：Synchronized，Lock，Condition
=========================================
####1、synchronized
把代码块声明为synchronized，有两个重要后果，通常是指该代码具有原子性（automicity）和可见性（visibility）。

#####原子性
原子性意味着某个时刻，只有一个线程能够执行一段代码，这段代码通过一个monitor Object保护。从而防止多个线程在更新共享状态时相互冲突。

#####可见性
可见性要对付内存缓存和编译器优化的各种反常行为。它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。
  **作用**：如果没有同步机制提供这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。
  **原理**：当对象获取锁时，它首先使自己的高速缓存无效，这样就可以保证直接从主内存中装入变量。同样，在对象释放锁之前，它会刷新其高速缓存，
  强制使已做的任何更改都出现在主内存中。这样，可以保证在同一个锁上同步的两个线程看到在synchronized块内修改的变量的相同值。

  一般来说，线程以某种不必让其他线程立即可以看到的方式（不管这些线程在寄存器中、在处理器特定的缓存中，还是通过指令重排或者其他编译器优化），
  不受缓存变量值的约束，但是如果开发人员使用了同步，那么运行库将确保某一线程对变量所做的更新先于对现有synchronized块所进行的更新，
  当进入由同一监控器（lock）保护的另一个synchronized块时，将立刻可以看到这些对变量所做的更新。
  类似的规则也存在与volatile变量上————————**volatile只保证可见性，不保证原子性**。

#####同步
