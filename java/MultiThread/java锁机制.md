Java锁机制：Synchronized，Lock，Condition
=========================================
####1、synchronized
把代码块声明为synchronized，有两个重要后果，通常是指该代码具有原子性（automicity）和可见性（visibility）。

#####原子性
原子性意味着某个时刻，只有一个线程能够执行一段代码，这段代码通过一个monitor Object保护。从而防止多个线程在更新共享状态时相互冲突。

#####可见性
可见性要对付内存缓存和编译器优化的各种反常行为。它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。

**作用**：如果没有同步机制提供这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。
  
**原理**：当对象获取锁时，它首先使自己的高速缓存无效，这样就可以保证直接从主内存中装入变量。同样，在对象释放锁之前，它会刷新其高速缓存 ，
  
强制使已做的任何更改都出现在主内存中。这样，可以保证在同一个锁上同步的两个线程看到在synchronized块内修改的变量的相同值。

一般来说，线程以某种不必让其他线程立即可以看到的方式（不管这些线程在寄存器中、在处理器特定的缓存中，还是通过指令重排或者其他编译器优化），不受缓存变量值的约束，但是如果开发人员使用了同步，那么运行库将确保某一线程对变量所做的更新先于对现有synchronized块所进行的更新，当进入由同一监控器（lock）保护的另一个synchronized块时，将立刻可以看到这些对变量所做的更新。
  
类似的规则也存在与volatile变量上————————**volatile只保证可见性，不保证原子性**。

#####需要同步的场景
**可见性同步**的基本规则是在以下情况中必须同步：

>1.读取上一次可能是由另一个线程写入的变量
2.写入下一次可能由另一个线程读取的变量

**一致性同步**：当修改多个相关值时，你想要其他线程原子地看到这组更改——要么看到全部更改，要么什么也看不到。

这适用于相关数据项（如粒子的位置和速率）和元数据项（如链表中包含的数据值和列表自身中的数据项的链）

但在某些情况中，不必用同步来将数据从一个线程传递到另一个，因为JVM已经隐含地为您执行同步。这些情况包括：

>1.由静态初始化器（在静态字段上或static{}块中的初始化器）
2.初始化数据时
3.访问final字段时
4.在创建线程之前创建对象时
5.线程可以看见它将要处理的对象

#####synchronized的限制
synchronized有一些功能上的限制：
>1.它无法中断一个正在等候获得锁的线程
2.无法通过投票得到锁，如果不想等下去，也就没法得到锁
3.同步还要求锁的释放只能在与获得锁所在的堆栈帧相同的堆栈帧中进行，多数情况下，这没问题（而且与异常处理交互的很好），但是，确实存在一些非块结构的锁更合适的情况

####ReentrantLock
Java.util.concurrent.lock的Lock框架是锁定的一个抽象，它允许把锁定的实现作为Java类，而不是作为语言的特性来实现。
