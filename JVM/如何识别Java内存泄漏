  Java利用垃圾回收机制来自动保持应用程序内存的干净和健康。然而，即使使用了垃圾回收机制，Java中仍然可能存在内存泄漏风险。
  如果遇到下面的错误代码：
        java.lang.OutOfMemoryError:Java heap space
  如果确认是内存分配不足，那么可以通过下述参数为应用程序增加可用内存：
        java -Xms<initial heap size> -Xmx<maximum heap size>
  对于内存泄漏来说，这样做治标不治本，只能起到缓解作用。
  
  内存泄漏的识别
    在将程序部署到生产环境之前检查一下是否存在内存泄漏的问题是很有必要的。
    可以通过垃圾收集器的指标来进行初步的判断。
    
  缩小问题的范围
      要找出内存泄漏的原因当下已经有许多工具可用，比如JVisualVM和jStat。这些工具都是JDK自带的，所以随时能用。
      除了要识别一些常用的内部Java类，一些用户自定义类同样需要识别。
      
  性能优化
      日常开发过程中，只要GC没有影响到性能，开发者就不会去关注内存设置与配置。从而埋下了潜在的隐患：
      因为内存问题并不只有溢出和泄漏，GC时间过长同样会造成这个问题。
      
  Heap设置
      Heap太小会导致频繁的GC，从而情景不难想象：增加GC会消耗更多的CPU，同时在GC时JVM会被冻结，最后导致一个很差的性能。
      总的来说，Heap太小，虽然GC时间变短，但是会变得更加频繁。
      
      Heap太大会导致GC时间变长。GC不会经常发生，但是一旦被触发，那么VM会被冻结很久。
      如果这种情况下发生内存泄漏，在最终JVM因为内存溢出崩溃之前，GC会非常频繁或者时间特别长。
      
  GC版本
      Java 7引入了G1GC作为CMSGC的替代选择，Java 9中G1GC成为默认选择。
      Java 8中移除了PermGen Space,之前存储在PermGen Space中的数据改为存储在本地内存或者栈中。
